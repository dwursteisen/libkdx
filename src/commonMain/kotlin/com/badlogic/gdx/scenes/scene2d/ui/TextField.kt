/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.badlogic.gdx.scenes.scene2d.ui

import com.badlogic.gdx.scenes.scene2d.ui.TextField.OnscreenKeyboard
import com.badlogic.gdx.scenes.scene2d.ui.TextField.TextFieldStyle

/**
 * A single-line text input field.
 *
 *
 * The preferred height of a text field is the height of the [TextFieldStyle.font] and [TextFieldStyle.background].
 * The preferred width of a text field is 150, a relatively arbitrary size.
 *
 *
 * The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is
 * pressed. Clipboard functionality is provided via the [Clipboard] interface. Currently there are two standard
 * implementations, one for the desktop and one for Android. The Android clipboard is a stub, as copy & pasting on Android is not
 * supported yet.
 *
 *
 * The text field allows you to specify an [OnscreenKeyboard] for displaying a softkeyboard and piping all key events
 * generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.
 * The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android [OnscreenKeyboard]
 * implementation will bring up the default IME.
 *
 * @author mzechner
 * @author Nathan Sweet
 */
class TextField(text: String?, style: TextFieldStyle?) : Widget(), Disableable {

    protected var text: String? = null
    protected var cursor = 0
    var selectionStart = 0
        protected set
    protected var hasSelection = false
    protected var writeEnters = false
    protected val layout: GlyphLayout = GlyphLayout()
    protected val glyphPositions: FloatArray = FloatArray()
    var style: TextFieldStyle? = null
    /**
     * @return May be null.
     */
    /**
     * Sets the text that will be drawn in the text field if no text has been entered.
     *
     * @param messageText may be null.
     */
    var messageText: String? = null
    protected var displayText: CharSequence? = null
    var clipboard: Clipboard? = null
    var inputListener: InputListener? = null
    var listener: TextFieldListener? = null

    /**
     * @param filter May be null.
     */
    var textFieldFilter: TextFieldFilter? = null

    /**
     * Default is an instance of [DefaultOnscreenKeyboard].
     */
    var onscreenKeyboard: OnscreenKeyboard = DefaultOnscreenKeyboard()
    var focusTraversal = true
    var onlyFontChars = true
    var isDisabled = false

    /**
     * Sets text horizontal alignment (left, center or right).
     *
     * @see Align
     */
    var alignment: Int = Align.left
    private var selectionX = 0f
    private var selectionWidth = 0f
    var undoText: String? = ""
    var lastChangeTime: Long = 0
    var passwordMode = false
    private var passwordBuffer: java.lang.StringBuilder? = null
    private var passwordCharacter = BULLET
    protected var fontOffset = 0f
    protected var textHeight = 0f
    protected var textOffset = 0f
    var renderOffset = 0f
    private var visibleTextStart = 0
    private var visibleTextEnd = 0
    var maxLength = 0
    var focused = false
    var cursorOn = false
    var blinkTime = 0.32f
    val blinkTask: Task = object : Task() {
        fun run() {
            if (getStage() == null) {
                cancel()
                return
            }
            cursorOn = !cursorOn
            Gdx.graphics.requestRendering()
        }
    }
    val keyRepeatTask = KeyRepeatTask()

    /**
     * If false, methods that change the text will not fire [ChangeEvent], the event will be fired only when user changes
     * the text.
     */
    var programmaticChangeEvents = false

    constructor(text: String?, skin: Skin) : this(text, skin.get(TextFieldStyle::class.java)) {}
    constructor(text: String?, skin: Skin, styleName: String?) : this(text, skin.get(styleName, TextFieldStyle::class.java)) {}

    protected fun initialize() {
        addListener(createInputListener().also({ inputListener = it }))
    }

    protected fun createInputListener(): InputListener {
        return TextFieldClickListener()
    }

    protected fun letterUnderCursor(x: Float): Int {
        var x = x
        x -= textOffset + fontOffset - style!!.font.getData().cursorX - glyphPositions[visibleTextStart]
        val background: Drawable? = backgroundDrawable
        if (background != null) x -= style!!.background.getLeftWidth()
        val n = glyphPositions.size
        val glyphPositions: FloatArray = glyphPositions.items
        for (i in 1 until n) {
            if (glyphPositions[i] > x) {
                return if (glyphPositions[i] - x <= x - glyphPositions[i - 1]) i else i - 1
            }
        }
        return n - 1
    }

    protected fun isWordCharacter(c: Char): Boolean {
        return java.lang.Character.isLetterOrDigit(c)
    }

    protected fun wordUnderCursor(at: Int): IntArray {
        val text = text
        var right = text!!.length
        var left = 0
        var index = at
        if (at >= text.length) {
            left = text.length
            right = 0
        } else {
            while (index < right) {
                if (!isWordCharacter(text[index])) {
                    right = index
                    break
                }
                index++
            }
            index = at - 1
            while (index > -1) {
                if (!isWordCharacter(text[index])) {
                    left = index + 1
                    break
                }
                index--
            }
        }
        return intArrayOf(left, right)
    }

    fun wordUnderCursor(x: Float): IntArray {
        return wordUnderCursor(letterUnderCursor(x))
    }

    fun withinMaxLength(size: Int): Boolean {
        return maxLength <= 0 || size < maxLength
    }

    /**
     * When false, text set by [.setText] may contain characters not in the font, a space will be displayed instead.
     * When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped
     * when typed or pasted.
     */
    fun setOnlyFontChars(onlyFontChars: Boolean) {
        this.onlyFontChars = onlyFontChars
    }

    fun setStyle(style: TextFieldStyle?) {
        if (style == null) throw java.lang.IllegalArgumentException("style cannot be null.")
        this.style = style
        textHeight = style.font.getCapHeight() - style.font.getDescent() * 2
        invalidateHierarchy()
    }

    /**
     * Returns the text field's style. Modifying the returned style may not have an effect until [.setStyle]
     * is called.
     */
    fun getStyle(): TextFieldStyle? {
        return style
    }

    protected fun calculateOffsets() {
        var visibleWidth: Float = getWidth()
        val background: Drawable? = backgroundDrawable
        if (background != null) visibleWidth -= background.getLeftWidth() + background.getRightWidth()
        val glyphCount = glyphPositions.size
        val glyphPositions: FloatArray = glyphPositions.items

        // Check if the cursor has gone out the left or right side of the visible area and adjust renderOffset.
        val distance = glyphPositions[java.lang.Math.max(0, cursor - 1)] + renderOffset
        if (distance <= 0) renderOffset -= distance else {
            val index: Int = java.lang.Math.min(glyphCount - 1, cursor + 1)
            val minX = glyphPositions[index] - visibleWidth
            if (-renderOffset < minX) renderOffset = -minX
        }

        // Prevent renderOffset from starting too close to the end, eg after text was deleted.
        var maxOffset = 0f
        val width = glyphPositions[glyphCount - 1]
        for (i in glyphCount - 2 downTo 0) {
            val x = glyphPositions[i]
            if (width - x > visibleWidth) break
            maxOffset = x
        }
        if (-renderOffset > maxOffset) renderOffset = -maxOffset

        // calculate first visible char based on render offset
        visibleTextStart = 0
        var startX = 0f
        for (i in 0 until glyphCount) {
            if (glyphPositions[i] >= -renderOffset) {
                visibleTextStart = i
                startX = glyphPositions[i]
                break
            }
        }

        // calculate last visible char based on visible width and render offset
        var end = visibleTextStart + 1
        val endX = visibleWidth - renderOffset
        val n: Int = java.lang.Math.min(displayText!!.length, glyphCount)
        while (end <= n) {
            if (glyphPositions[end] > endX) break
            end++
        }
        visibleTextEnd = java.lang.Math.max(0, end - 1)
        if (alignment and Align.left === 0) {
            textOffset = visibleWidth - glyphPositions[visibleTextEnd] - fontOffset + startX
            if (alignment and Align.center !== 0) textOffset = java.lang.Math.round(textOffset * 0.5f).toFloat()
        } else textOffset = startX + renderOffset

        // calculate selection x position and width
        if (hasSelection) {
            val minIndex: Int = java.lang.Math.min(cursor, selectionStart)
            val maxIndex: Int = java.lang.Math.max(cursor, selectionStart)
            val minX: Float = java.lang.Math.max(glyphPositions[minIndex] - glyphPositions[visibleTextStart], -textOffset)
            val maxX: Float = java.lang.Math.min(glyphPositions[maxIndex] - glyphPositions[visibleTextStart], visibleWidth - textOffset)
            selectionX = minX
            selectionWidth = maxX - minX - style!!.font.getData().cursorX
        }
    }

    private val backgroundDrawable: Drawable?
        private get() {
            val focused: Boolean = hasKeyboardFocus()
            return if (isDisabled && style!!.disabledBackground != null) style!!.disabledBackground else if (focused && style!!.focusedBackground != null) style!!.focusedBackground else style!!.background
        }

    fun draw(batch: Batch, parentAlpha: Float) {
        val focused: Boolean = hasKeyboardFocus()
        if (focused != this.focused) {
            this.focused = focused
            blinkTask.cancel()
            cursorOn = focused
            if (focused) Timer.schedule(blinkTask, blinkTime, blinkTime) else keyRepeatTask.cancel()
        } else if (!focused) //
            cursorOn = false
        val font: BitmapFont? = style!!.font
        val fontColor: Color = if (isDisabled && style!!.disabledFontColor != null) style!!.disabledFontColor else if (focused && style!!.focusedFontColor != null) style!!.focusedFontColor else style!!.fontColor
        val selection: Drawable? = style!!.selection
        val cursorPatch: Drawable? = style!!.cursor
        val background: Drawable? = backgroundDrawable
        val color: Color = getColor()
        val x: Float = getX()
        val y: Float = getY()
        val width: Float = getWidth()
        val height: Float = getHeight()
        batch.setColor(color.r, color.g, color.b, color.a * parentAlpha)
        var bgLeftWidth = 0f
        var bgRightWidth = 0f
        if (background != null) {
            background.draw(batch, x, y, width, height)
            bgLeftWidth = background.getLeftWidth()
            bgRightWidth = background.getRightWidth()
        }
        val textY = getTextY(font, background)
        calculateOffsets()
        if (focused && hasSelection && selection != null) {
            drawSelection(selection, batch, font, x + bgLeftWidth, y + textY)
        }
        val yOffset: Float = if (font.isFlipped()) -textHeight else 0
        if (displayText!!.length == 0) {
            if (!focused && messageText != null) {
                val messageFont: BitmapFont = if (style!!.messageFont != null) style!!.messageFont else font
                if (style!!.messageFontColor != null) {
                    messageFont.setColor(style!!.messageFontColor.r, style!!.messageFontColor.g, style!!.messageFontColor.b,
                        style!!.messageFontColor.a * color.a * parentAlpha)
                } else messageFont.setColor(0.7f, 0.7f, 0.7f, color.a * parentAlpha)
                drawMessageText(batch, messageFont, x + bgLeftWidth, y + textY + yOffset, width - bgLeftWidth - bgRightWidth)
            }
        } else {
            font.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * color.a * parentAlpha)
            drawText(batch, font, x + bgLeftWidth, y + textY + yOffset)
        }
        if (!isDisabled && cursorOn && cursorPatch != null) {
            drawCursor(cursorPatch, batch, font, x + bgLeftWidth, y + textY)
        }
    }

    protected fun getTextY(font: BitmapFont?, background: Drawable?): Float {
        val height: Float = getHeight()
        var textY: Float = textHeight / 2 + font.getDescent()
        textY = if (background != null) {
            val bottom: Float = background.getBottomHeight()
            textY + (height - background.getTopHeight() - bottom) / 2 + bottom
        } else {
            textY + height / 2
        }
        if (font.usesIntegerPositions()) textY = textY as Int.toFloat()
        return textY
    }

    /**
     * Draws selection rectangle
     */
    protected fun drawSelection(selection: Drawable, batch: Batch?, font: BitmapFont, x: Float, y: Float) {
        selection.draw(batch, x + textOffset + selectionX + fontOffset, y - textHeight - font.getDescent(), selectionWidth,
            textHeight)
    }

    protected fun drawText(batch: Batch?, font: BitmapFont?, x: Float, y: Float) {
        font.draw(batch, displayText, x + textOffset, y, visibleTextStart, visibleTextEnd, 0, Align.left, false)
    }

    protected fun drawMessageText(batch: Batch?, font: BitmapFont?, x: Float, y: Float, maxWidth: Float) {
        font.draw(batch, messageText, x, y, 0, messageText!!.length, maxWidth, alignment, false, "...")
    }

    protected fun drawCursor(cursorPatch: Drawable, batch: Batch?, font: BitmapFont, x: Float, y: Float) {
        cursorPatch.draw(batch,
            x + textOffset + glyphPositions[cursor] - glyphPositions[visibleTextStart] + fontOffset + font.getData().cursorX,
            y - textHeight - font.getDescent(), cursorPatch.getMinWidth(), textHeight)
    }

    fun updateDisplayText() {
        val font: BitmapFont? = style!!.font
        val data: BitmapFontData = font.getData()
        val text = text
        val textLength = text!!.length
        val buffer: java.lang.StringBuilder = java.lang.StringBuilder()
        for (i in 0 until textLength) {
            val c = text[i]
            buffer.append(if (data.hasGlyph(c)) c else ' ')
        }
        val newDisplayText: String = buffer.toString()
        if (passwordMode && data.hasGlyph(passwordCharacter)) {
            if (passwordBuffer == null) passwordBuffer = java.lang.StringBuilder(newDisplayText.length)
            if (passwordBuffer.length > textLength) passwordBuffer.setLength(textLength) else {
                for (i in passwordBuffer.length until textLength) passwordBuffer.append(passwordCharacter)
            }
            displayText = passwordBuffer
        } else displayText = newDisplayText
        layout.setText(font, displayText.toString().replace('\r', ' ').replace('\n', ' '))
        glyphPositions.clear()
        var x = 0f
        if (layout.runs.size > 0) {
            val run: GlyphRun = layout.runs.first()
            val xAdvances: FloatArray = run.xAdvances
            fontOffset = xAdvances.first()
            var i = 1
            val n = xAdvances.size
            while (i < n) {
                glyphPositions.add(x)
                x += xAdvances[i]
                i++
            }
        } else fontOffset = 0f
        glyphPositions.add(x)
        visibleTextStart = java.lang.Math.min(visibleTextStart, glyphPositions.size - 1)
        visibleTextEnd = MathUtils.clamp(visibleTextEnd, visibleTextStart, glyphPositions.size - 1)
        if (selectionStart > newDisplayText.length) selectionStart = textLength
    }

    /**
     * Copies the contents of this TextField to the [Clipboard] implementation set on this TextField.
     */
    fun copy() {
        if (hasSelection && !passwordMode) {
            clipboard.setContents(text!!.substring(java.lang.Math.min(cursor, selectionStart), java.lang.Math.max(cursor, selectionStart)))
        }
    }

    /**
     * Copies the selected contents of this TextField to the [Clipboard] implementation set on this TextField, then removes
     * it.
     */
    fun cut() {
        cut(programmaticChangeEvents)
    }

    fun cut(fireChangeEvent: Boolean) {
        if (hasSelection && !passwordMode) {
            copy()
            cursor = delete(fireChangeEvent)
            updateDisplayText()
        }
    }

    fun paste(content: String?, fireChangeEvent: Boolean) {
        var content = content ?: return
        val buffer: java.lang.StringBuilder = java.lang.StringBuilder()
        var textLength = text!!.length
        if (hasSelection) textLength -= java.lang.Math.abs(cursor - selectionStart)
        val data: BitmapFontData = style!!.font.getData()
        var i = 0
        val n = content.length
        while (i < n) {
            if (!withinMaxLength(textLength + buffer.length)) break
            val c = content[i]
            if (!(writeEnters && (c == ENTER_ANDROID || c == ENTER_DESKTOP))) {
                if (c == '\r' || c == '\n') {
                    i++
                    continue
                }
                if (onlyFontChars && !data.hasGlyph(c)) {
                    i++
                    continue
                }
                if (textFieldFilter != null && !textFieldFilter!!.acceptChar(this, c)) {
                    i++
                    continue
                }
            }
            buffer.append(c)
            i++
        }
        content = buffer.toString()
        if (hasSelection) cursor = delete(fireChangeEvent)
        if (fireChangeEvent) changeText(text, insert(cursor, content, text)) else text = insert(cursor, content, text)
        updateDisplayText()
        cursor += content.length
    }

    fun insert(position: Int, text: CharSequence?, to: String?): String {
        return if (to!!.length == 0) text.toString() else to.substring(0, position) + text + to.substring(position, to.length)
    }

    fun delete(fireChangeEvent: Boolean): Int {
        val from = selectionStart
        val to = cursor
        val minIndex: Int = java.lang.Math.min(from, to)
        val maxIndex: Int = java.lang.Math.max(from, to)
        val newText = ((if (minIndex > 0) text!!.substring(0, minIndex) else "")
            + if (maxIndex < text!!.length) text!!.substring(maxIndex, text!!.length) else "")
        if (fireChangeEvent) changeText(text, newText) else text = newText
        clearSelection()
        return minIndex
    }

    /**
     * Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage.
     *
     * @param up If true, the TextField with the same or next smallest y coordinate is found, else the next highest.
     */
    fun next(up: Boolean) {
        val stage: Stage = getStage() ?: return
        var current = this
        val currentCoords: Vector2 = current.getParent().localToStageCoordinates(tmp2.set(current.getX(), current.getY()))
        val bestCoords: Vector2 = tmp1
        while (true) {
            var textField = current.findNextTextField(stage.getActors(), null, bestCoords, currentCoords, up)
            if (textField == null) { // Try to wrap around.
                if (up) currentCoords.set(-Float.MAX_VALUE, -Float.MAX_VALUE) else currentCoords.set(Float.MAX_VALUE, Float.MAX_VALUE)
                textField = current.findNextTextField(stage.getActors(), null, bestCoords, currentCoords, up)
            }
            if (textField == null) {
                Gdx.input.setOnscreenKeyboardVisible(false)
                break
            }
            if (stage.setKeyboardFocus(textField)) {
                textField.selectAll()
                break
            }
            current = textField
            currentCoords.set(bestCoords)
        }
    }

    /**
     * @return May be null.
     */
    private fun findNextTextField(actors: Array<Actor>, best: TextField?, bestCoords: Vector2, currentCoords: Vector2,
                                  up: Boolean): TextField? {
        var best = best
        var i = 0
        val n = actors.size
        while (i < n) {
            val actor: Actor = actors[i]
            if (actor is TextField) {
                if (actor === this) {
                    i++
                    continue
                }
                val textField = actor as TextField
                if (textField.isDisabled || !textField.focusTraversal || !textField.ancestorsVisible()) {
                    i++
                    continue
                }
                val actorCoords: Vector2 = actor.getParent().localToStageCoordinates(tmp3.set(actor.getX(), actor.getY()))
                val below = actorCoords.y !== currentCoords.y && actorCoords.y < currentCoords.y xor up
                val right = actorCoords.y === currentCoords.y && actorCoords.x > currentCoords.x xor up
                if (!below && !right) {
                    i++
                    continue
                }
                var better = best == null || actorCoords.y !== bestCoords.y && actorCoords.y > bestCoords.y xor up
                if (!better) better = actorCoords.y === bestCoords.y && actorCoords.x < bestCoords.x xor up
                if (better) {
                    best = actor
                    bestCoords.set(actorCoords)
                }
            } else if (actor is Group) best = findNextTextField((actor as Group).getChildren(), best, bestCoords, currentCoords, up)
            i++
        }
        return best
    }

    val defaultInputListener: InputListener?
        get() = inputListener

    /**
     * @param listener May be null.
     */
    fun setTextFieldListener(listener: TextFieldListener?) {
        this.listener = listener
    }

    /**
     * If true (the default), tab/shift+tab will move to the next text field.
     */
    fun setFocusTraversal(focusTraversal: Boolean) {
        this.focusTraversal = focusTraversal
    }

    /**
     * @param str If null, "" is used.
     */
    fun appendText(str: String?) {
        var str = str
        if (str == null) str = ""
        clearSelection()
        cursor = text!!.length
        paste(str, programmaticChangeEvents)
    }

    /**
     * @param str If null, "" is used.
     */
    fun setText(str: String?) {
        var str = str
        if (str == null) str = ""
        if (str == text) return
        clearSelection()
        val oldText = text
        text = ""
        paste(str, false)
        if (programmaticChangeEvents) changeText(oldText, text)
        cursor = 0
    }

    /**
     * @return Never null, might be an empty string.
     */
    fun getText(): String? {
        return text
    }

    /**
     * @param oldText May be null.
     * @return True if the text was changed.
     */
    fun changeText(oldText: String?, newText: String?): Boolean {
        if (newText == oldText) return false
        text = newText
        val changeEvent: ChangeEvent = Pools.obtain(ChangeEvent::class.java)
        val cancelled: Boolean = fire(changeEvent)
        text = if (cancelled) oldText else newText
        Pools.free(changeEvent)
        return !cancelled
    }

    val selection: String
        get() = if (hasSelection) text!!.substring(java.lang.Math.min(selectionStart, cursor), java.lang.Math.max(selectionStart, cursor)) else ""

    /**
     * Sets the selected text.
     */
    fun setSelection(selectionStart: Int, selectionEnd: Int) {
        var selectionStart = selectionStart
        var selectionEnd = selectionEnd
        if (selectionStart < 0) throw java.lang.IllegalArgumentException("selectionStart must be >= 0")
        if (selectionEnd < 0) throw java.lang.IllegalArgumentException("selectionEnd must be >= 0")
        selectionStart = java.lang.Math.min(text!!.length, selectionStart)
        selectionEnd = java.lang.Math.min(text!!.length, selectionEnd)
        if (selectionEnd == selectionStart) {
            clearSelection()
            return
        }
        if (selectionEnd < selectionStart) {
            val temp = selectionEnd
            selectionEnd = selectionStart
            selectionStart = temp
        }
        hasSelection = true
        this.selectionStart = selectionStart
        cursor = selectionEnd
    }

    fun selectAll() {
        setSelection(0, text!!.length)
    }

    fun clearSelection() {
        hasSelection = false
    }

    /**
     * Sets the cursor position and clears any selection.
     */
    var cursorPosition: Int
        get() = cursor
        set(cursorPosition) {
            if (cursorPosition < 0) throw java.lang.IllegalArgumentException("cursorPosition must be >= 0")
            clearSelection()
            cursor = java.lang.Math.min(cursorPosition, text!!.length)
        }

    fun setClipboard(clipboard: Clipboard?) {
        this.clipboard = clipboard
    }

    val prefWidth: Float
        get() = 150

    val prefHeight: Float
        get() {
            var topAndBottom = 0f
            var minHeight = 0f
            if (style!!.background != null) {
                topAndBottom = java.lang.Math.max(topAndBottom, style!!.background.getBottomHeight() + style!!.background.getTopHeight())
                minHeight = java.lang.Math.max(minHeight, style!!.background.getMinHeight())
            }
            if (style!!.focusedBackground != null) {
                topAndBottom = java.lang.Math.max(topAndBottom,
                    style!!.focusedBackground.getBottomHeight() + style!!.focusedBackground.getTopHeight())
                minHeight = java.lang.Math.max(minHeight, style!!.focusedBackground.getMinHeight())
            }
            if (style!!.disabledBackground != null) {
                topAndBottom = java.lang.Math.max(topAndBottom,
                    style!!.disabledBackground.getBottomHeight() + style!!.disabledBackground.getTopHeight())
                minHeight = java.lang.Math.max(minHeight, style!!.disabledBackground.getMinHeight())
            }
            return java.lang.Math.max(topAndBottom + textHeight, minHeight)
        }

    /**
     * If true, the text in this text field will be shown as bullet characters.
     *
     * @see .setPasswordCharacter
     */
    fun setPasswordMode(passwordMode: Boolean) {
        this.passwordMode = passwordMode
        updateDisplayText()
    }

    fun isPasswordMode(): Boolean {
        return passwordMode
    }

    /**
     * Sets the password character for the text field. The character must be present in the [BitmapFont]. Default is 149
     * (bullet).
     */
    fun setPasswordCharacter(passwordCharacter: Char) {
        this.passwordCharacter = passwordCharacter
        if (passwordMode) updateDisplayText()
    }

    fun setBlinkTime(blinkTime: Float) {
        this.blinkTime = blinkTime
    }

    protected fun moveCursor(forward: Boolean, jump: Boolean) {
        val limit = if (forward) text!!.length else 0
        val charOffset = if (forward) 0 else -1
        while ((if (forward) ++cursor < limit else --cursor > limit) && jump) {
            if (!continueCursor(cursor, charOffset)) break
        }
    }

    protected fun continueCursor(index: Int, offset: Int): Boolean {
        val c = text!![index + offset]
        return isWordCharacter(c)
    }

    inner class KeyRepeatTask : Task() {
        var keycode = 0
        fun run() {
            if (getStage() == null) {
                cancel()
                return
            }
            inputListener.keyDown(null, keycode)
        }
    }

    /**
     * Interface for listening to typed characters.
     *
     * @author mzechner
     */
    interface TextFieldListener {

        fun keyTyped(textField: TextField?, c: Char)
    }

    /**
     * Interface for filtering characters entered into the text field.
     *
     * @author mzechner
     */
    interface TextFieldFilter {

        fun acceptChar(textField: TextField?, c: Char): Boolean
        class DigitsOnlyFilter : TextFieldFilter {
            override fun acceptChar(textField: TextField?, c: Char): Boolean {
                return java.lang.Character.isDigit(c)
            }
        }
    }

    /**
     * An interface for onscreen keyboards. Can invoke the default keyboard or render your own keyboard!
     *
     * @author mzechner
     */
    interface OnscreenKeyboard {

        fun show(visible: Boolean)
    }

    /**
     * The default [OnscreenKeyboard] used by all [TextField] instances. Just uses
     * [Input.setOnscreenKeyboardVisible] as appropriate. Might overlap your actual rendering, so use with care!
     *
     * @author mzechner
     */
    class DefaultOnscreenKeyboard : OnscreenKeyboard {

        override fun show(visible: Boolean) {
            Gdx.input.setOnscreenKeyboardVisible(visible)
        }
    }

    /**
     * Basic input listener for the text field
     */
    inner class TextFieldClickListener : ClickListener() {

        fun clicked(event: InputEvent?, x: Float, y: Float) {
            val count: Int = getTapCount() % 4
            if (count == 0) clearSelection()
            if (count == 2) {
                val array = wordUnderCursor(x)
                setSelection(array[0], array[1])
            }
            if (count == 3) selectAll()
        }

        fun touchDown(event: InputEvent?, x: Float, y: Float, pointer: Int, button: Int): Boolean {
            if (!super.touchDown(event, x, y, pointer, button)) return false
            if (pointer == 0 && button != 0) return false
            if (isDisabled) return true
            setCursorPosition(x, y)
            selectionStart = cursor
            val stage: Stage = getStage()
            if (stage != null) stage.setKeyboardFocus(this@TextField)
            onscreenKeyboard.show(true)
            hasSelection = true
            return true
        }

        fun touchDragged(event: InputEvent?, x: Float, y: Float, pointer: Int) {
            super.touchDragged(event, x, y, pointer)
            setCursorPosition(x, y)
        }

        fun touchUp(event: InputEvent?, x: Float, y: Float, pointer: Int, button: Int) {
            if (selectionStart == cursor) hasSelection = false
            super.touchUp(event, x, y, pointer, button)
        }

        protected fun setCursorPosition(x: Float, y: Float) {
            cursor = letterUnderCursor(x)
            cursorOn = focused
            blinkTask.cancel()
            if (focused) Timer.schedule(blinkTask, blinkTime, blinkTime)
        }

        protected fun goHome(jump: Boolean) {
            cursor = 0
        }

        protected fun goEnd(jump: Boolean) {
            cursor = text!!.length
        }

        fun keyDown(event: InputEvent?, keycode: Int): Boolean {
            if (isDisabled) return false
            cursorOn = focused
            blinkTask.cancel()
            if (focused) Timer.schedule(blinkTask, blinkTime, blinkTime)
            if (!hasKeyboardFocus()) return false
            var repeat = false
            val ctrl: Boolean = UIUtils.ctrl()
            val jump = ctrl && !passwordMode
            var handled = true
            if (ctrl) {
                when (keycode) {
                    Keys.V -> {
                        paste(clipboard.getContents(), true)
                        repeat = true
                    }
                    Keys.C, Keys.INSERT -> {
                        copy()
                        return true
                    }
                    Keys.X -> {
                        cut(true)
                        return true
                    }
                    Keys.A -> {
                        selectAll()
                        return true
                    }
                    Keys.Z -> {
                        val oldText = text
                        setText(undoText)
                        undoText = oldText
                        updateDisplayText()
                        return true
                    }
                    else -> handled = false
                }
            }
            if (UIUtils.shift()) {
                when (keycode) {
                    Keys.INSERT -> paste(clipboard.getContents(), true)
                    Keys.FORWARD_DEL -> cut(true)
                }
                selection@{
                    val temp = cursor
                    keys@{
                        when (keycode) {
                            Keys.LEFT -> {
                                moveCursor(false, jump)
                                repeat = true
                                handled = true
                                break@keys
                            }
                            Keys.RIGHT -> {
                                moveCursor(true, jump)
                                repeat = true
                                handled = true
                                break@keys
                            }
                            Keys.HOME -> {
                                goHome(jump)
                                handled = true
                                break@keys
                            }
                            Keys.END -> {
                                goEnd(jump)
                                handled = true
                                break@keys
                            }
                        }
                        break@selection
                    }
                    if (!hasSelection) {
                        selectionStart = temp
                        hasSelection = true
                    }
                }
            } else {
                // Cursor movement or other keys (kills selection).
                when (keycode) {
                    Keys.LEFT -> {
                        moveCursor(false, jump)
                        clearSelection()
                        repeat = true
                        handled = true
                    }
                    Keys.RIGHT -> {
                        moveCursor(true, jump)
                        clearSelection()
                        repeat = true
                        handled = true
                    }
                    Keys.HOME -> {
                        goHome(jump)
                        clearSelection()
                        handled = true
                    }
                    Keys.END -> {
                        goEnd(jump)
                        clearSelection()
                        handled = true
                    }
                }
            }
            cursor = MathUtils.clamp(cursor, 0, text!!.length)
            if (repeat) scheduleKeyRepeatTask(keycode)
            return handled
        }

        protected fun scheduleKeyRepeatTask(keycode: Int) {
            if (!keyRepeatTask.isScheduled() || keyRepeatTask.keycode != keycode) {
                keyRepeatTask.keycode = keycode
                keyRepeatTask.cancel()
                Timer.schedule(keyRepeatTask, keyRepeatInitialTime, keyRepeatTime)
            }
        }

        fun keyUp(event: InputEvent?, keycode: Int): Boolean {
            if (isDisabled) return false
            keyRepeatTask.cancel()
            return true
        }

        fun keyTyped(event: InputEvent?, character: Char): Boolean {
            if (isDisabled) return false
            when (character) {
                BACKSPACE, TAB, ENTER_ANDROID, ENTER_DESKTOP -> {
                }
                else -> if (character.toInt() < 32) return false
            }
            if (!hasKeyboardFocus()) return false
            if (UIUtils.isMac && Gdx.input.isKeyPressed(Keys.SYM)) return true
            if ((character == TAB || character == ENTER_ANDROID) && focusTraversal) {
                next(UIUtils.shift())
            } else {
                val delete = character == DELETE
                val backspace = character == BACKSPACE
                val enter = character == ENTER_DESKTOP || character == ENTER_ANDROID
                val add = if (enter) writeEnters else !onlyFontChars || style!!.font.getData().hasGlyph(character)
                val remove = backspace || delete
                if (add || remove) {
                    val oldText = text
                    val oldCursor = cursor
                    if (remove) {
                        if (hasSelection) cursor = delete(false) else {
                            if (backspace && cursor > 0) {
                                text = text!!.substring(0, cursor - 1) + text!!.substring(cursor--)
                                renderOffset = 0f
                            }
                            if (delete && cursor < text!!.length) {
                                text = text!!.substring(0, cursor) + text!!.substring(cursor + 1)
                            }
                        }
                    }
                    if (add && !remove) {
                        // Character may be added to the text.
                        if (!enter && textFieldFilter != null && !textFieldFilter!!.acceptChar(this@TextField, character)) return true
                        if (!withinMaxLength(text!!.length)) return true
                        if (hasSelection) cursor = delete(false)
                        val insertion = if (enter) "\n" else character.toString()
                        text = insert(cursor++, insertion, text)
                    }
                    val tempUndoText = undoText
                    if (changeText(oldText, text)) {
                        val time: Long = java.lang.System.currentTimeMillis()
                        if (time - 750 > lastChangeTime) undoText = oldText
                        lastChangeTime = time
                    } else cursor = oldCursor
                    updateDisplayText()
                }
            }
            if (listener != null) listener!!.keyTyped(this@TextField, character)
            return true
        }
    }

    /**
     * The style for a text field, see [TextField].
     *
     * @author mzechner
     * @author Nathan Sweet
     */
    class TextFieldStyle {

        var font: BitmapFont? = null
        var fontColor: Color? = null

        /**
         * Optional.
         */
        var focusedFontColor: Color? = null
        var disabledFontColor: Color? = null

        /**
         * Optional.
         */
        var background: Drawable? = null
        var focusedBackground: Drawable? = null
        var disabledBackground: Drawable? = null
        var cursor: Drawable? = null
        var selection: Drawable? = null

        /**
         * Optional.
         */
        var messageFont: BitmapFont? = null

        /**
         * Optional.
         */
        var messageFontColor: Color? = null

        constructor() {}
        constructor(font: BitmapFont?, fontColor: Color?, cursor: Drawable?, selection: Drawable?, background: Drawable?) {
            this.background = background
            this.cursor = cursor
            this.font = font
            this.fontColor = fontColor
            this.selection = selection
        }

        constructor(style: TextFieldStyle) {
            messageFont = style.messageFont
            if (style.messageFontColor != null) messageFontColor = Color(style.messageFontColor)
            background = style.background
            focusedBackground = style.focusedBackground
            disabledBackground = style.disabledBackground
            cursor = style.cursor
            font = style.font
            if (style.fontColor != null) fontColor = Color(style.fontColor)
            if (style.focusedFontColor != null) focusedFontColor = Color(style.focusedFontColor)
            if (style.disabledFontColor != null) disabledFontColor = Color(style.disabledFontColor)
            selection = style.selection
        }
    }

    companion object {
        private const val BACKSPACE = 8.toChar()
        protected const val ENTER_DESKTOP = '\r'
        protected const val ENTER_ANDROID = '\n'
        private const val TAB = '\t'
        private const val DELETE = 127.toChar()
        private const val BULLET = 149.toChar()
        private val tmp1: Vector2 = Vector2()
        private val tmp2: Vector2 = Vector2()
        private val tmp3: Vector2 = Vector2()
        var keyRepeatInitialTime = 0.4f
        var keyRepeatTime = 0.1f
    }

    init {
        setStyle(style)
        clipboard = Gdx.app.getClipboard()
        initialize()
        setText(text)
        setSize(prefWidth, prefHeight)
    }
}
