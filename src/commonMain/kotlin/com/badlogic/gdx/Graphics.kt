/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.badlogic.gdx

import com.badlogic.gdx.graphics.Cursor
import com.badlogic.gdx.graphics.Cursor.SystemCursor
import com.badlogic.gdx.graphics.GL20
import com.badlogic.gdx.graphics.GL30
import com.badlogic.gdx.graphics.Pixmap
import com.badlogic.gdx.graphics.glutils.GLVersion

/** This interface encapsulates communication with the graphics processor. Depending on the available hardware and the current
 * [Application] configuration, access to [GL20] and [GL30] are provided here.
 *
 *
 * If supported by the backend, this interface lets you query the available display modes (graphics resolution and color depth)
 * and change it.
 *
 *
 * This interface can be used to switch between continuous and non-continuous rendering (see
 * [.setContinuousRendering]), and to explicitly [.requestRendering].
 *
 *
 * There are many more utility classes that are not directly generated by the [Graphics] interfaces. See [VertexArray]
 * , [VertexBufferObject], [IndexBufferObject], [Mesh], [ShaderProgram] and [FrameBuffer],
 * [BitmapFont], [Batch] and so on. All these classes are managed, meaning they don't need to be reloaded on a context
 * loss. Explore the com.badlogic.gdx.graphics package for more classes that might come in handy.
 * @author mzechner
 */
interface Graphics {

    /** Enumeration describing different types of [Graphics] implementations.
     *
     * @author mzechner
     */
    enum class GraphicsType {

        AndroidGL, LWJGL, WebGL, iOSGL, JGLFW, Mock, LWJGL3
    }

    /** Describe a fullscreen display mode
     *
     * @author mzechner
     */
    class DisplayMode protected constructor(
        /** the width in physical pixels  */
        val width: Int,
        /** the height in physical pixles  */
        val height: Int,
        /** the refresh rate in Hertz  */
        val refreshRate: Int,
        /** the number of bits per pixel, may exclude alpha  */
        val bitsPerPixel: Int) {

        override fun toString(): String {
            return width.toString() + "x" + height + ", bpp: " + bitsPerPixel + ", hz: " + refreshRate
        }
    }

    /** Describes a monitor
     *
     * @author badlogic
     */
    class Monitor protected constructor(val virtualX: Int, val virtualY: Int, val name: String?)

    /** Class describing the bits per pixel, depth buffer precision, stencil precision and number of MSAA samples.  */
    class BufferFormat(/* number of bits per color channel */
        val r: Int, val g: Int, val b: Int, val a: Int, /* number of bits for depth and stencil buffer */
        val depth: Int, val stencil: Int,
        /** number of samples for multi-sample anti-aliasing (MSAA)  */
        val samples: Int,
        /** whether coverage sampling anti-aliasing is used. in that case you have to clear the coverage buffer as well!  */
        val coverageSampling: Boolean) {

        override fun toString(): String {
            return ("r: " + r + ", g: " + g + ", b: " + b + ", a: " + a + ", depth: " + depth + ", stencil: " + stencil
                + ", num samples: " + samples + ", coverage sampling: " + coverageSampling)
        }
    }

    /** Returns whether OpenGL ES 3.0 is available. If it is you can get an instance of [GL30] via [.getGL30] to
     * access OpenGL ES 3.0 functionality. Note that this functionality will only be available if you instructed the
     * [Application] instance to use OpenGL ES 3.0!
     *
     * @return whether OpenGL ES 3.0 is available
     */
    val isGL30Available: Boolean

    /** @return the [GL20] instance
     */
    fun getGL20(): GL20?

    /** @return the [GL30] instance or null if not supported
     */
    fun getGL30(): GL30?

    /** Set the GL20 instance  */
    fun setGL20(gl20: GL20?)

    /** Set the GL30 instance  */
    fun setGL30(gl30: GL30?)

    /** @return the width of the client area in logical pixels.
     */
    val width: Int

    /** @return the height of the client area in logical pixels
     */
    val height: Int

    /** @return the width of the framebuffer in physical pixels
     */
    val backBufferWidth: Int

    /** @return the height of the framebuffer in physical pixels
     */
    val backBufferHeight: Int

    /** Returns the id of the current frame. The general contract of this method is that the id is incremented only when the
     * application is in the running state right before calling the [ApplicationListener.render] method. Also, the id of
     * the first frame is 0; the id of subsequent frames is guaranteed to take increasing values for 2<sup>63</sup>-1 rendering
     * cycles.
     * @return the id of the current frame
     */
    val frameId: Long

    /** @return the time span between the current frame and the last frame in seconds. Might be smoothed over n frames.
     */
    val deltaTime: Float

    /** @return the time span between the current frame and the last frame in seconds, without smoothing
     */
    val rawDeltaTime: Float

    /** @return the average number of frames per second
     */
    val framesPerSecond: Int

    /** @return the [GraphicsType] of this Graphics instance
     */
    val type: GraphicsType?

    /** @return the [GLVersion] of this Graphics instance
     */
    val gLVersion: GLVersion?

    /** @return the pixels per inch on the x-axis
     */
    val ppiX: Float

    /** @return the pixels per inch on the y-axis
     */
    val ppiY: Float

    /** @return the pixels per centimeter on the x-axis
     */
    val ppcX: Float

    /** @return the pixels per centimeter on the y-axis.
     */
    val ppcY: Float

    /** This is a scaling factor for the Density Independent Pixel unit, following the same conventions as
     * android.util.DisplayMetrics#density, where one DIP is one pixel on an approximately 160 dpi screen. Thus on a 160dpi screen
     * this density value will be 1; on a 120 dpi screen it would be .75; etc.
     *
     * @return the logical density of the Display.
     */
    val density: Float

    /** Whether the given backend supports a display mode change via calling [Graphics.setFullscreenMode]
     *
     * @return whether display mode changes are supported or not.
     */
    fun supportsDisplayModeChange(): Boolean

    /** @return the primary monitor
     */
    val primaryMonitor: Monitor?

    /** @return the monitor the application's window is located on
     */
    val monitor: Monitor?

    /** @return the currently connected [Monitor]s
     */
    val monitors: Array<Monitor?>?

    /** @return the supported fullscreen [DisplayMode](s) of the monitor the window is on
     */
    val displayModes: Array<DisplayMode?>?

    /** @return the supported fullscreen [DisplayMode]s of the given [Monitor]
     */
    fun getDisplayModes(monitor: Monitor?): Array<DisplayMode?>?

    /** @return the current [DisplayMode] of the monitor the window is on.
     */
    val displayMode: DisplayMode?

    /** @return the current [DisplayMode] of the given [Monitor]
     */
    fun getDisplayMode(monitor: Monitor?): DisplayMode?

    /** Sets the window to full-screen mode.
     *
     * @param displayMode the display mode.
     * @return whether the operation succeeded.
     */
    fun setFullscreenMode(displayMode: DisplayMode?): Boolean

    /** Sets the window to windowed mode.
     *
     * @param width the width in pixels
     * @param height the height in pixels
     * @return whether the operation succeeded
     */
    fun setWindowedMode(width: Int, height: Int): Boolean

    /** Sets the title of the window. Ignored on Android.
     *
     * @param title the title.
     */
    fun setTitle(title: String?)

    /** Sets the window decoration as enabled or disabled. On Android, this will enable/disable
     * the menu bar.
     *
     * Note that immediate behavior of this method may vary depending on the implementation. It
     * may be necessary for the window to be recreated in order for the changes to take effect.
     * Consult the documentation for the backend in use for more information.
     *
     * Supported on all GDX desktop backends and on Android (to disable the menu bar).
     *
     * @param undecorated true if the window border or status bar should be hidden. false otherwise.
     */
    fun setUndecorated(undecorated: Boolean)

    /** Sets whether or not the window should be resizable. Ignored on Android.
     *
     * Note that immediate behavior of this method may vary depending on the implementation. It
     * may be necessary for the window to be recreated in order for the changes to take effect.
     * Consult the documentation for the backend in use for more information.
     *
     * Supported on all GDX desktop backends.
     *
     * @param resizable
     */
    fun setResizable(resizable: Boolean)

    /** Enable/Disable vsynching. This is a best-effort attempt which might not work on all platforms.
     *
     * @param vsync vsync enabled or not.
     */
    fun setVSync(vsync: Boolean)

    /** @return the format of the color, depth and stencil buffer in a [BufferFormat] instance
     */
    val bufferFormat: BufferFormat?

    /** @param extension the extension name
     * @return whether the extension is supported
     */
    fun supportsExtension(extension: String?): Boolean

    /** @return whether rendering is continuous.
     */
    /** Sets whether to render continuously. In case rendering is performed non-continuously, the following events will trigger a
     * redraw:
     *
     *
     *  * A call to [.requestRendering]
     *  * Input events from the touch screen/mouse or keyboard
     *  * A [Runnable] is posted to the rendering thread via [Application.postRunnable]. In the case
     * of a multi-window app, all windows will request rendering if a runnable is posted to the application. To avoid this,
     * post a runnable to the window instead.
     *
     *
     * Life-cycle events will also be reported as usual, see [ApplicationListener]. This method can be called from any
     * thread.
     *
     * @param isContinuous whether the rendering should be continuous or not.
     */
    var isContinuousRendering: Boolean

    /** Requests a new frame to be rendered if the rendering mode is non-continuous. This method can be called from any thread.  */
    fun requestRendering()

    /** Whether the app is fullscreen or not  */
    val isFullscreen: Boolean

    /** Create a new cursor represented by the [com.badlogic.gdx.graphics.Pixmap]. The Pixmap must be in RGBA8888 format,
     * width & height must be powers-of-two greater than zero (not necessarily equal) and of a certain minimum size (32x32 is a safe bet),
     * and alpha transparency must be single-bit (i.e., 0x00 or 0xFF only). This function returns a Cursor object that can be set as the
     * system cursor by calling [.setCursor] .
     *
     * @param pixmap the mouse cursor image as a [com.badlogic.gdx.graphics.Pixmap]
     * @param xHotspot the x location of the hotspot pixel within the cursor image (origin top-left corner)
     * @param yHotspot the y location of the hotspot pixel within the cursor image (origin top-left corner)
     * @return a cursor object that can be used by calling [.setCursor] or null if not supported
     */
    fun newCursor(pixmap: Pixmap?, xHotspot: Int, yHotspot: Int): Cursor?

    /** Only viable on the lwjgl-backend and on the gwt-backend. Browsers that support cursor:url() and support the png format (the
     * pixmap is converted to a data-url of type image/png) should also support custom cursors. Will set the mouse cursor image to
     * the image represented by the [com.badlogic.gdx.graphics.Cursor]. It is recommended to call this function in the main render thread, and maximum one time per frame.
     *
     * @param cursor the mouse cursor as a [com.badlogic.gdx.graphics.Cursor]
     */
    fun setCursor(cursor: Cursor?)

    /**
     * Sets one of the predefined [SystemCursor]s
     */
    fun setSystemCursor(systemCursor: SystemCursor?)
}
